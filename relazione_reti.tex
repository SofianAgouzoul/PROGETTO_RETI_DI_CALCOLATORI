\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{float}
\graphicspath{
    {./IMMAGINI SERVER/}
    {./IMMAGINI CLIENT/}
    {./FILE AGGIUNTIVI/}
}

\title{PROGETTO\_ESAME\_RETI\_NOBLER\_AGOUZOUL}
\author{Sofian Agouzoul, 0124002029\\Matteo Nobler, 0124001853}

\date{03/Dicembre/2024}
\begin{document}

\raggedright\par
\maketitle\textbf{Starship}

\part{Traccia}
Una navicella spaziale deve evitare i detriti provenienti da una tempesta di meteoriti.
La navicella (client) entra nel settore spaziale dei meteoriti (server) connettendosi in UDP.
La tempesta di meteoriti genera in modo casuale n pacchetti UDP ogni 2 secondi che rappresentano i detriti in una griglia MxM. 
La navicella riceve un alert nel caso in cui il detrito spaziale si trovi sulla sua stessa posizione e può spostarsi prima dell'impatto.
Ogni spostamento della navicella viene notificato al server il quale genera nuovi detriti nella direzione della navicella stessa.

\section{DETTAGLI IMPLEMENTATIVI}
L'applicazione è stata codificata seguendo il paradigma client-server, con i due che adoperano il protocollo UDP per comunicare tra di loro. \newline
Mediante l'utilizzo delle funzioni sendto() e recvfrom(), il client ed il server, comunicano tra loro scambiandosi pacchetti UDP ogni 2 secondi. Ricordiamo che queste funzioni sono l'equivalente delle funzioni read() e write().
\newline
In particolare, il server genera i meteoriti, ovvero i pacchetti UDP, e li invia al client che dovrà spostarsi all'interno della griglia di gioco per evitare eventuali collisioni.
Di seguito si riportano le specifiche implementative del Server e del Client:
\newpage

\part{CORPO DEL SERVER}
\section{PROCEDURE}
\begin{enumerate}
    %INITIALIZE SERVER
    \begin{figure}[!htb]
     \item PROCEDURA INITIALIZE\_SERVER() \newline
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI SERVER/INITIALIZE_SERVER.png}
        \raggedright\par
        Questa funzione incapsula la fase creazione della socket adoperata per la comunicazione con un client. Banalmente crea il file-descriptor della socket, imposta correttamente Porta e Indirizzo IP su cui tale server risponde e richiama la bind() per assegnare tale combinazione [IP;Porta] al descrittore della socket. \newline
        Se tutte le operazioni vanno a buon fine, è ritornato il file-descriptor della socket.
    \end{figure}
    
   \begin{figure}[!htb]
    %UPDATE METEORITES
    \item PROCEDURA UPDATE\_METEORITES() \newline
       \centering
       \includegraphics[width=1\linewidth]{IMMAGINI SERVER/UPDATE_METEORITES.png}
       \raggedright\par
        Questa funzione si occupa di spostare le meteore dall'alto verso il basso, con un andamento che potremmo definire "a cascata". Per fare ciò, semplicemente l'indice di riga di una meteora viene incrementato (perchè si passa da una riga più in alto, che ha un indice più piccolo, a una riga più in basso, che ha un indice più grande). \newline
       Incrementando l'indice di riga, ovviamente prima o poi la meteora raggiungerà la riga più bassa della matrice, e in tal caso essa viene rimossa, decrementando anche il numero di meteore presenti sul campo.
   \end{figure}

   \begin{figure}[!htb] 
   %CHECK COLLISION
   \item PROCEDURA CHECK\_COLLISION() \newline
       \centering
       \includegraphics[width=1\linewidth]{IMMAGINI SERVER/CHECK_COLLISION.png}
       \raggedright\par
       Questa funzione si occupa di vedere se l'astronave ha colliso con un meteorite. L'idea è che si vede ogni meteorite presente se ha colliso con l'astronave. \newline
       La collisione avviene se ascissa e ordinata dell'astronave (ship\_x;ship\_y) coincidono con ascissa e ordinata di un meteorite (meteorites[i][0];meteorites[i][1]). \newline
       Verificando ogni meteorite, se si trova quello che ha colliso, si memorizzano ascissa e ordinata di tale meteorite, si valorizza a 1 la variabile che indica l'avvenuta collisione e si esce dal ciclo di controllo (visto che si è trovato il meteorite che ha impattato non è necessario continuare a verificare).
   \end{figure}

   \begin{figure}[!htb]
   %GENERATE NEW METEORITES
   \item PROCEDURA GENERATES\_NEW\_METEORITES() \newline
       \centering
       \includegraphics[width=1\linewidth]{IMMAGINI SERVER/GENERATES_NEW_METEORITES.png}
       \label{fig:enter-label}
       \raggedright\par
       Questa funzione si occupa di generare un nuovo meteorite se possibile, ossia se sul campo vi è un numero di meteoriti inferiore a un limite superiore impostato mediante macro. \newline
       Il meteorite viene generato nella riga più in alto della matrice del campo di meteore e nella stessa colonna dove si trova l'astronave. \newline
       Se si è riuscito a generare un nuovo meteorite, il contatore dei meteoriti presenti su campo viene incrementato. \newline
   \end{figure}

   \begin{figure}[!htb]
   %CHECK WARNING IMMINENT COLLISION
    \item PROCEDURA CHECK\_WARNING\_IMMINENT\_COLLISION() \newline
       \centering
       \includegraphics[width=1\linewidth]{IMMAGINI SERVER/CHECK_WARNING_IMMINENT_COLLISION.png}
       \raggedright\par
       Questa funzione si occupa di inviare un warning per avvisare il client della troppa vicinanza con un meteorite che si trova sulla sua stessa traiettoria, di fatto avvisandolo di doversi spostare per evitare l'impatto. \newline
       Essenzialmente la procedura verifica se il meteorite è sulla stessa colonna della matrice (meteorites[i][1] == ship\_y) e a una o due celle di distanza sopra a dove si trova l'astronave ((meteorites[i][0] == ship\_x - 1) or (meteorites[i][0] == ship\_x - 2)), e se questa condizione si verifica, delle apposite variabili vengono settate per indicare al server di avvisare il client dell'impatto imminente. \newline
       Più precisamente si imposta imminent\_collision a 1 per indicare che c'è il rischio di impatto imminente, e si valorizzano imminent\_met\_x e imminent\_met\_y per specificare quale è il meteorite con cui si sta rischiando di impattarsi. \newline
   \end{figure}

    \begin{figure}[!htb]
    %SEND METEORITES
    \item PROCEDURA SEND\_METEORITES() \newline
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI SERVER/SEND_METEORITES.png}
        \raggedright\par
        Questa funzione richiama al suo interno in ciclo la funzione sendto() per inviare i vari meteoriti generati al client. \newline
        Conoscendo il numero 'meteorite\_count' di meteoriti presenti sul campo (che era correttamente valorizzato e controllato da generate\_new\_meteorites()), il ciclo di invio meteoriti viene ripetuto per 'meteorite\_count' volte, e, terminato il ciclo, un ulteriore sendto() invierà un valore speciale (che è semplicemente un -1) per indicare che tutti i meteoriti che dovevano essere inviati sono stati inviati. \newline
    \end{figure}

    \begin{figure}[!htb]
    %RECEIVE SHIP POSITION
    \item PROCEDURA RECEIVE\_SHIP\_POSITION()
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI SERVER/RECEIVE_SHIP_POSITION.png}
        \raggedright\par
        Questa funzione richiama al suo interno una recvfrom() per ricevere in un buffer la posizione della navicella client. \newline
        Il buffer è formattato in una maniera preimpostata, in maniera tale che con una sscanf() siano correttamente leggibili e valorizzabili le variabili intere new\_x e new\_y contenenti ascissa e ordinata di dove si trova la navicella dopo uno spostamento.
        A partire da queste variabili, basta fare due assegnazioni per valorizzare correttamente le coordinate (ship\_x;ship\_y) della navicella.
    \end{figure}

    \begin{figure}[!htb]
    %PRINT GRID
    \item PROCEDURA PRINT\_GRID()
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI SERVER/PRINT_GRID.png}
        \raggedright\par
Questa funzione si occupa di utilizzare le variabili ship\_x, ship\_y e il set di coordinate meteorites[][] dei meteoriti per stampare graficamente una matrice con dei simboli indicanti la posizione spaziale di meteoriti e navicella sul campo. \newline
In pratica questa funzione si occupa di mostrare un resoconto grafico della partita, stampando una matrice di caratteri rappresentante il campo di gioco, così che l'utente abbia modo di capire quali sono mosse più ottimali per proseguire senza andarsi a schiantare su un meteorite e perdere. \newline Per i simboli usati usati per la grafica si è deciso come segue: \newline
        '.' : indica uno spazio vuoto libero\\
        '*' : indica un meteorite\\
        'S' : indica la navicella\\
    \end{figure}

    %MAIN SERVER
    \begin{figure}[!htb]
    \item MAIN\_SERVER\_1
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI SERVER/MAIN_SERVER_PT1.png}
        \raggedright\par
        Il server inizia impostando correttamente il suo insieme (ID;Porta) che andrà a usare e la socket stessa adoperata per la comunicazione.
        Chiamando poi receive\_ship\_position(), si bloccherà in attesa di ricevere la posizione iniziale della navicella client.
        Ricevuta tale posizione, si entra nel loop principale del gioco.
        Il protocollo di livello applicazione usato dal server per la comunicazione con il client è composto dai seguenti passaggi, ripetuti in loop:
        \item[1] Genera nuovi meteoriti nella riga più in altro della matrice che fa da campo di gioco
        \item[2] Stampa suddetta griglia per avere un resoconto grafico della situazione
        \item[3] Invia I meteoriti generati al client per rendergli nota la loro posizione
        \item[4] Vedi se il client è troppo vicino a uno dei meteoriti e nel caso invia un messaggio di warning
    \end{figure}

    \begin{figure}[!htb]
    \item MAIN\_SERVER\_PT2
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI SERVER/MAIN_SERVER_PT2.png}
        \raggedright\par
        \item[5] Se non è vicino a un meteorite, nessun messaggio di warning va inviato, ergo il server invierà un messaggio vuoto per evitare che il client resti bloccato su una recvfrom()
        \item[6] Attende che il client invii un comando; innanzitutto vede se il comando è una richiesta di uscire dal gioco, ergo resta bloccato su una prima recvrom()
        \item[7] Se il client non ha richiesto di uscire, il server proseguirà e riceverà con un apposita funzione la nuova posizione della navicella
        \item[8] In seguito al movimento, il server controlla eventuali collisioni
        \item[9] Adoperando una funzione check\_collision(), viene valorizzata un apposita variabile per indicare se vi è stata o meno una collisione. Se questa collisione è avvenuta, viene inviato al client il messaggio che ha perso, indicando anche le coordinate del meteorite su cui si è schiantato. 
        \item[10] Se la collisione non è avvenuta, la partita può proseguire. I meteoriti possono spostarsi verso il basso.
        \item[11] Poichè però si deve vedere anche se in seguito allo spostamento dei meteoriti il client ha colliso (questa cosa può avvenire se navicella e meteorite erano sulla stessa colonna e vi era un solo spazio vuoto di distanza tra i due), è nuovamente richiamata check\_collision(), con l'invio dell'esito del check.
        
    \end{figure}

    \begin{figure}[!htb]
    \item MAIN\_SERVER\_PT3
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI SERVER/MAIN_SERVER_PT3.png}
        \raggedright\par
        In questo ultimo blocco del main, se viene settata la variabile collision ad 1, il server stamperà un messaggio per cui la navicella si collide con un meteorite, scollegandosi e terminando cosi la partita.
    \end{figure}
    \end{enumerate}

    \begin{enumerate}
    \begin{figure}[!htb]
    \part{CORPO DEL CLIENT}
    \section{PROCEDURE}
    \item PROCEDURA RECV\_WARNING()
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI CLIENT/RECV_WARNING.png}
        \raggedright\par
        Questa funzione si occupa di recuperare eventuali messaggi di warning che il server ha inviato al client per avvisarlo della presenza di un meteorite troppo vicino a lui.
        Essenzialmente la funzione vede se il server ha inviato un messaggio di warning usando una prima recvfrom() per recuperare la lunghezza del messaggio inviato. \newline
        Se è recuperata una lunghezza superiore agli 0 caratteri, allora il messaggio di warning esiste, e quindi la funzione procederà invocando una seconda recvfrom() per recuperare il messaggio di warning vero e proprio. \newline 
        La prima recvfrom() dice anche quanto è lungo il messaggio di warning, ergo da anche informazione alla seconda recvfrom() su quanti bytes aspettarsi di ricevere come messaggio di warning.
    \end{figure}

    \begin{figure}[!htb]
    \item PROCEDURA CONTROL\_GAME()
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI CLIENT/CONTROL_GAME.png}
        \raggedright\par
        Questa funzione incapsula i controlli di gioco che il client può usare per muovere la navicella. Il giocatore da terminale potrà premere uno dei quattro tasti W,A,S o D per indicare in quale direzione la navicella si deve muovere (in ordine: Alto, Sinistra, Sotto, Destra). \newline
        Controllando con degli if() a catena il tasto premuto, la navicella si sposterà di una casella nella direzione desiderata incrementando o decrementando la sua ascissa o la sua ordinata di un'unità, a patto che in quella direzione vi sia spazio per muoversi (se, ad esempio, la navicella prova a spostarsi a destra, ma essa sta già al bordo destro della mappa, non è possibile spostarsi ulteriormente a destra). \newline
        Inoltre è possibile premere il tasto 'q' per far si che il client notifichi al server della sua intenzione di volersi disconnettere dalla partita.
    \end{figure}

    \begin{figure}[!htb]
        \item MAIN\_CLIENT\_PT1
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI CLIENT/MAIN_CLIENT_PT1.png}
        \raggedright\par
        La funzione main() del programma client inizia valorizzando con le apposite funzioni tutte le variabili necessarie per specificare correttamente il server con cui si comunicherà mediante protocollo UDP. \newline
        Vi è quindi la fase di creazione del file-descriptor sockfd della socket UDP con l'utilizzo della funzione socket() e specificando SOCK\_DGRAM come opzione per il protocollo di livello trasporto che si andrà ad utilizzare. \newline
        Vi è poi anche l'inizializzazione della struttura di tipo struct sockaddr\_in per indicare correttamente l'insieme (IP;Porta) su cui è attivo il server.
        Come ultima operazione di questa prima parte del main() vi è una prima sendto(), usata per inviare la posizione iniziale della navicella sul campo di gioco, così da permettere al server di sapere dove la navicella si trova inizialmente.
    \end{figure}
    
    \newpage
    
    \begin{figure}[!htb]
        \item MAIN\_CLIENT\_PT2
        \centering
        \includegraphics[width=1\linewidth]{IMMAGINI CLIENT/MAIN_CLIENT_PT2.png}    
        \raggedright\par
        Il main() poi continua, entrando nel vero loop infinito di gioco, che permette dunque a client e server di scambiare tra di loro informazioni e, di fatto, giocare una partita.
        Il protocollo di livello applicazione usato dal client per la comunicazione con il server è composto dai seguenti passaggi, ripetuti in loop:
        \item[1] Mettiti in ricezione delle coordinate dei vari meteoriti.
        \item[2] Mettiti in ricezione di eventuali messaggi di warning.
        \item[3] Dai all'utente possibilità di muovere la navicella o di uscire dalla partita.
        \item[4] Comunica al server se ci si vuole disconnettere o meno.
        \item[5] Formatta e invia correttamente le nuove coordinate a cui si trova ora la navicella dopo uno spostamento.
        \item[6] Mettiti in ricezione dell'esito del movimento per vedere se si è colliso o meno con un meteorite.
        \item[7] Mettiti in pausa per 2 secondi e reitera i passaggi di cui sopra.
    \end{figure}        
    \end{enumerate}

    
\begin{figure}[!htb]
\part{MANUALE ED ISTRUZIONI SU COMPILAZIONE ED ESECUZIONE}
    \paragraph{MAKEFILE}
        \centering
        \includegraphics[width=1\linewidth]{FILE AGGIUNTIVI/MAKEFILE.png}
        \raggedright\par
        Sopra è riportato il Makefile usato per la compilazione.
        Digitando banalmente il comando 'make' sul terminale, partirà in automatico la compilaizone dei due sorgenti. 
\end{figure}

\begin{figure}[!htb]
    \paragraph{SIMULAZIONE DI GIOCO}
    \centering
    \includegraphics[width=1\linewidth]{FILE AGGIUNTIVI/STEP_0_SERVER.png}
    \raggedright\par
    La situazione iniziale è che il client navicella parte nella riga più bassa della matrice a una posizione centrale, e un meteorite viene generato nella sua stessa colonna al lato opposto.
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1\linewidth]{FILE AGGIUNTIVI/STEP_0_CLIENT.png}
    \raggedright\par
    Lato client la posizione della navicella viene notificata e quindi si parte con il loop principale. Si può osservare che il programma client si bloccherà in attesa della pressione di uno dei tasti di movimento o del tasto di uscita.
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1\linewidth]{FILE AGGIUNTIVI/IMPATTO_IMMINENTE.png}
     \raggedright\par
     Il server visualizza graficamente lo stato in cui meteoriti e navicella si ritrovano in un dato istante temporale. \newline
     Se inoltre, la navicella è solo a una o due celle di distanza sotto un meteorite, verrà inviato un messaggio di Warning per segnalare di un impatto imminente.
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1\linewidth]{FILE AGGIUNTIVI/ALERT_IMPATTO_IMMINENTE.png}
    \raggedright\par
    Dopo un numero di cicli vediamo la situazione in cui la navicella si trova in una condizione di impatto imminente con un meteorite che si trova sulla sua stessa colonna. \newline
    L'alert viene inviato dal server qualora la navicella si trovi ad una cella di distanza dal meteorite o subito sotto di essa.
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1\linewidth]{FILE AGGIUNTIVI/COLLISIONE.png}
    \raggedright\par
    Riprendendo la situazione nella figura precedente, se muoviamo la navicella verso l'alto, questa impatterà il meteorite ,che tramite la funzione Update\_meteorites(), si sposta verso il basso. Di conseguenza, il server rileva la collisione ed invia un avviso di collisione al client, il quale si disconnetterà.
\end{figure}

\end{document}
